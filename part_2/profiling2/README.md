# پروژه تحلیل عملکرد و بهینه‌سازی با YourKit Java Profiler

## 🎯 هدف پروژه
هدف این پروژه شناسایی و بهینه‌سازی گلوگاه‌های مصرف منابع (CPU و حافظه) در یک برنامه جاوا با استفاده از ابزار **YourKit Java Profiler** است.

---

## 🧪 سناریو: شمارش فراوانی کلمات در متن

ما برنامه‌ای نوشته‌ایم که یک متن بسیار طولانی را که شامل تکرار تصادفی چند کلمه مشخص است، تولید کرده و سپس تعداد تکرار هر کلمه را محاسبه می‌کند.

---

## 🔹 نسخه 1: پیاده‌سازی غیربهینه (`WordCounter.java`)

### الگوریتم
1. ابتدا تمام کلمات در یک لیست ذخیره می‌شوند.
2. سپس، برای هر کلمه در لیست، یک بار دیگر کل لیست پیمایش می‌شود تا تعداد آن کلمه شمرده شود.
3. نتیجه در `HashMap` ذخیره می‌شود.

### تحلیل
- پیچیدگی زمانی: **O(n²)**
- مصرف حافظه بالا به‌خاطر لیست ذخیره‌ی کلمات
- حلقه‌های تو در تو باعث مصرف شدید CPU می‌شوند.


### تصویر YourKit (قبل از بهینه‌سازی):
![original.png](..%2Foriginal.png)

---

## ✅ نسخه 2: پیاده‌سازی بهینه‌شده (`WordCounterOptimized.java`)

### الگوریتم
1. همان لحظه که هر کلمه تولید می‌شود، شمارش آن در `HashMap` افزایش می‌یابد.
2. از لیست میانی صرف‌نظر شده است.
3. از `HashMap.getOrDefault()` برای افزایش شمارش استفاده شده.

### تحلیل
- پیچیدگی زمانی: **O(n)**
- حافظه کمتر
- اجرای سریع‌تر و مصرف CPU به‌مراتب پایین‌تر

### تصویر YourKit (بعد از بهینه‌سازی):
![optimized.png](..%2Foptimized.png)

---

## 📊 مقایسه عملکردی

| ویژگی‌ها                 | نسخه غیربهینه                    | نسخه بهینه‌شده                    |
|--------------------------|----------------------------------|-----------------------------------|
| پیچیدگی زمانی            | O(n²)                            | O(n)                              |
| استفاده از حافظه         | زیاد (ذخیره کلمات در لیست)      | کم (استفاده مستقیم از HashMap)   |
| مصرف CPU                | بسیار بالا                      | بسیار پایین                      |
| زمان اجرا (۱۰٬۰۰۰ کلمه) | حدود 4–6 ثانیه                   | کمتر از 0.5 ثانیه                 |
| ساختار داده اصلی         | `ArrayList` + `HashMap`          | فقط `HashMap`                    |

---

## 🧠 نتیجه‌گیری

استفاده از YourKit به ما امکان داد دقیقاً مشخص کنیم که کدام بخش از کد بیشترین مصرف منابع را دارد. با تغییر ساختار داده و الگوریتم، مصرف منابع به‌طور قابل توجهی بهینه شد. این پروژه نشان می‌دهد که تنها با تغییر در منطق برنامه (بدون حذف یا غیرفعال‌سازی کد)، می‌توان به عملکرد بسیار بهتر دست یافت.


---

## ⚠️ نکته
در این پروژه از فایل متنی استفاده نشده، بلکه یک تابع داخلی `generateLongText()` برای تولید متن بزرگ استفاده شده تا تحلیل به شکل دقیق‌تری و بدون وابستگی به فایل صورت گیرد.
